// SPDX-License-Identifier: GPL-2.0-only
/*
 * Copyright (C) 2023 Soaribox
 * Author: Steffen Dohse <steffen-dohse@web.de>
 *
 * MIPI Display driver for the Lincoln 7V070WUV 7 inch Display
 */

#include <linux/delay.h>
#include <linux/gpio/consumer.h>
#include <linux/module.h>
#include <linux/of.h>
#include <video/mipi_display.h>

#include <drm/drm_crtc.h>
#include <drm/drm_mipi_dsi.h>
#include <drm/drm_modes.h>
#include <drm/drm_panel.h>
#include <drm/drm_print.h>

struct lincoln_panel {
	struct drm_panel base;
	struct mipi_dsi_device *dsi;

	struct gpio_desc *enable_gpio;
	struct gpio_desc *reset_gpio;
	struct gpio_desc *dcdc_en_gpio;

	bool prepared;
	bool enabled;

	const struct drm_display_mode *mode;
};

static inline struct lincoln_panel *to_lincoln_panel(struct drm_panel *panel)
{
	return container_of(panel, struct lincoln_panel, base);
}

#define dsi_dcs_write_seq(dsi, cmd, seq...) do {                        \
                static const u8 b[] = { cmd, seq };                     \
                int ret;                                                \
                ret = mipi_dsi_generic_write(dsi, b, ARRAY_SIZE(b));	\
		msleep_interruptible(10);				\
		if (ret < 0)                                            \
                        return ret;                                     \
        } while (0)

static int lincoln_panel_init(struct lincoln_panel *lincoln)
{
	struct mipi_dsi_device *dsi = lincoln->dsi;
	struct device *dev = &lincoln->dsi->dev;
	int ret;

	dsi->mode_flags |= MIPI_DSI_MODE_LPM;

	printk(KERN_ERR "lincoln_PANEL_INIT: Beginning of Init");


//-------------  Display Initial Code Setting  -------------------------

//Stop reload
        dsi_dcs_write_seq(dsi, 0x50,0x5A);

	printk(KERN_ERR "lincoln_PANEL_INIT: After First command");


//INT CANCEL
        dsi_dcs_write_seq(dsi,0x54,0x03);

	printk(KERN_ERR "lincoln_PANEL_INIT: After Second command");
//VCOM
        dsi_dcs_write_seq(dsi,0x50,0x5A,0x03);
        dsi_dcs_write_seq(dsi,0x80,0xC2);

//Blank 8
        dsi_dcs_write_seq(dsi,0x50,0x5A,0x08);
        dsi_dcs_write_seq(dsi,0x80,0xC8,0x00);
//Blank 9
        dsi_dcs_write_seq(dsi,0x50,0x5A,0x09);
        dsi_dcs_write_seq(dsi,0x80,0x5A,0x51,0xB5,0xAA,0x6A,0xD5,0x4A,0x01,0x40,0xE1,0x0D,0x82,0x20,0x08,0x00,0xB4);
        dsi_dcs_write_seq(dsi,0x90,0x00,0x24,0x42,0x0A,0xE3,0x6D,0xDB,0xF4,0xF5,0xBE,0x7A,0x20,0x2D,0xA1,0x26,0x00);
        dsi_dcs_write_seq(dsi,0xA0,0xA1,0x80,0x08,0x20,0x06,0x00);
//Blank 10
        dsi_dcs_write_seq(dsi,0x50,0x5A,0x0A);
        dsi_dcs_write_seq(dsi,0x80,0x41,0x83,0x02,0x05,0x1B,0x2C,0x41,0x56,0x6A,0x73,0xA8,0xA1,0xD9,0x5F,0x2D,0x73);
        dsi_dcs_write_seq(dsi,0x90,0x4A,0x48,0x3A,0x2B,0x1D,0x11,0x08,0x05,0x1B,0x2C,0x41,0x56,0x6A,0x73,0xA8,0xA1);
        dsi_dcs_write_seq(dsi,0xA0,0xD9,0x5F,0x2D,0x73,0x4A,0x48,0x3A,0x2B,0x1D,0x11,0x08,0x00);
//Blank 11
        dsi_dcs_write_seq(dsi,0x50,0x5A,0x0B);
        dsi_dcs_write_seq(dsi,0x80,0x00,0x00,0x20,0x44,0x08,0x00,0x60,0x47,0x00,0x00,0x10,0x22,0x04,0x00,0xB0,0x23);
        dsi_dcs_write_seq(dsi,0x90,0x15,0x00);
//Blank 12
        dsi_dcs_write_seq(dsi,0x50,0x5A,0x0C);
        dsi_dcs_write_seq(dsi,0x80,0xFE,0x68,0x58,0x02,0x3C,0x64,0xB8,0x06,0x00,0x60,0x15,0x00,0x50,0x15,0x56,0x51);
        dsi_dcs_write_seq(dsi,0x90,0x15,0x55,0x61,0x15,0x00,0x60,0x15,0x00,0x50,0x15,0x56,0x51,0x15,0x55,0x61,0x95);
        dsi_dcs_write_seq(dsi,0xA0,0xAB,0x18,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x4C,0x29,0x84,0x52,0x01,0x09,0x00);
//Blank 13
        dsi_dcs_write_seq(dsi,0x50,0x5A,0x0D);
        dsi_dcs_write_seq(dsi,0x80,0xF0,0xB1,0x71,0xEF,0x49,0xC0,0x80,0x1A,0x00,0x00,0x00,0x00,0x00,0x00);
//Blank 14
        dsi_dcs_write_seq(dsi,0x50,0x5A,0x0E);
        dsi_dcs_write_seq(dsi,0x80,0xFF,0x81,0x68,0xAC,0x22,0x6D,0x24,0x00,0x00,0x00,0x00,0x00);
//Blank 15
        dsi_dcs_write_seq(dsi,0x50,0x5A,0x0F);
        dsi_dcs_write_seq(dsi,0x80,0x5B,0x02,0x4A,0x00,0x25,0x80,0x64,0x0C,0x51,0x31,0x28,0x81,0x03,0x42,0x8C,0x8C);
        dsi_dcs_write_seq(dsi,0x90,0x24,0x69,0x81,0x71,0x44,0x7C,0x14);
//Blank 16
        dsi_dcs_write_seq(dsi,0x50,0x5A,0x10);
        dsi_dcs_write_seq(dsi,0x80,0x00,0x00,0x03,0xE7,0x1F,0x17,0x00,0x78,0x00,0x03,0xD4,0x18,0x30,0x88,0x41,0x8A);
        dsi_dcs_write_seq(dsi,0x90,0x39,0x28,0xA9,0xC5,0x9A,0x7B,0xF5,0x07,0x7E,0xE0,0x07,0x7E,0x20,0x10,0x00);
//Blank 17
        dsi_dcs_write_seq(dsi,0x50,0x5A,0x11);
        dsi_dcs_write_seq(dsi,0x80,0x44,0x77,0x03,0x40,0x8A,0xF1,0xFF,0x43,0x30,0x08,0xC1,0x46,0xA0,0x80,0x24,0x18);
        dsi_dcs_write_seq(dsi,0x90,0x30,0x06,0x64,0xC1,0x80,0x21,0x07,0xC4,0xE1,0xD0,0x68,0x40,0x20,0x1D,0x04,0x48);
        dsi_dcs_write_seq(dsi,0xA0,0x40,0x40,0x28,0x10,0x90,0x70,0x38,0x1A,0x10,0x47,0x03,0xE2,0x20,0x00,0x1C,0x80);
        dsi_dcs_write_seq(dsi,0xB0,0x50,0x30,0x00,0xE0,0xE1,0x01,0x00,0x28,0x0E,0x06,0x03,0x0D,0x11,0x11,0x11,0x11);
        dsi_dcs_write_seq(dsi,0xC0,0x91,0x88,0x88,0x88,0x88,0x88,0xC8,0x08,0x86,0xC6,0xE3,0x81,0x00,0x20,0x00,0x21);
        dsi_dcs_write_seq(dsi,0xD0,0x42,0x88,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x31,0x04,0x41,0x06,0x00,0x00,0x00);
        dsi_dcs_write_seq(dsi,0xE0,0x00,0x92,0x24,0x49,0x92,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x85,0x11,0x0C);
        dsi_dcs_write_seq(dsi,0xF0,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x5E,0x00);
//Blank 18
        dsi_dcs_write_seq(dsi,0x50,0x5A,0x12);
        dsi_dcs_write_seq(dsi,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00);
        dsi_dcs_write_seq(dsi,0x90,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00);
//Blank 19
        dsi_dcs_write_seq(dsi,0x50,0x5A,0x13);
        dsi_dcs_write_seq(dsi,0x80,0x01,0x00,0x00,0x0C,0x00,0x00,0x00,0x00,0x01,0x02,0x01,0x01,0x44,0x6C,0xCE,0xE7);
        dsi_dcs_write_seq(dsi,0x90,0x62,0x06,0x00);
//Blank 20
        dsi_dcs_write_seq(dsi,0x50,0x5A,0x14);
        dsi_dcs_write_seq(dsi,0x80,0x11,0x02,0x40,0x5E,0xE9,0xEF,0xF7,0xFB,0xFD,0x7E,0x01,0x00,0xC0,0xE2,0xC5,0xC9);
        dsi_dcs_write_seq(dsi,0x90,0x9A,0x3C,0x20,0x3E,0xD6,0xE4,0x01,0x53,0xB1,0x26,0x0F,0x98,0x8C,0x35,0x79,0x40);
        dsi_dcs_write_seq(dsi,0xA0,0xDC,0xAC,0xC9,0x23,0x00,0x60,0x4D,0x0E,0x03,0xC0,0x8B,0x12,0x30,0xF1,0x1D,0x20);
        dsi_dcs_write_seq(dsi,0xB0,0x88,0x8A,0xC7,0x37,0x00,0x00,0x00,0x00,0x00,0x1C,0xBC,0xBF,0x2B,0x00,0x40,0xA1);
        dsi_dcs_write_seq(dsi,0xC0,0x50,0x78,0x07,0x6B,0xF2,0x80,0x31,0x00,0x6F,0x60,0x4D,0x1E,0x30,0x06,0xE0,0x05);
        dsi_dcs_write_seq(dsi,0xD0,0xAC,0xC9,0x03,0xC6,0x00,0xBC,0x82,0x35,0x79,0xC0,0x18,0x80,0x77,0xB1,0x26,0x0F);
        dsi_dcs_write_seq(dsi,0xE0,0x18,0x03,0xF0,0x26,0xD6,0xE4,0x01,0x63,0x00,0xDE,0xC3,0x9A,0x3C,0x60,0x0C,0xC0);
        dsi_dcs_write_seq(dsi,0xF0,0x5B,0x58,0x93,0x07,0x8C,0x01,0x00,0x01,0xBF,0x1F,0x00,0x00,0x00,0x00,0x00,0x00);
//Blank 21
        dsi_dcs_write_seq(dsi,0x50,0x5A,0x15);
        dsi_dcs_write_seq(dsi,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00);
        dsi_dcs_write_seq(dsi,0x90,0x00,0x00,0xC8,0x73,0x00,0x98,0xF8,0x86,0x18,0x7C,0x19,0x00,0x26,0xBE,0x21,0x06);
        dsi_dcs_write_seq(dsi,0xA0,0xDF,0x7E,0x88,0x89,0x6F,0x88,0xC1,0xF7,0x1D,0x61,0xE2,0x1B,0x62,0xF0,0x05,0x00);
        dsi_dcs_write_seq(dsi,0xB0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x13,0x00,0xF0,0x00,0x94,0xD6,0x71,0xD6);
        dsi_dcs_write_seq(dsi,0xC0,0x55,0x14,0xA3,0x49,0x51,0x0C,0x43,0x10,0xB0,0x71,0x04,0xC1,0x30,0x6C,0x01,0x60);
        dsi_dcs_write_seq(dsi,0xD0,0x5D,0x45,0x51,0x82,0x08,0x02,0x41,0x18,0x06,0x1B,0xC7,0x30,0x04,0xC1,0x96,0x61);
        dsi_dcs_write_seq(dsi,0xE0,0xD6,0x55,0x14,0x21,0x09,0x41,0x08,0x02,0x00,0xB0,0x71,0x04,0xC1,0x30,0x6C,0x05);
        dsi_dcs_write_seq(dsi,0xF0,0x61,0x5D,0x45,0x71,0x8A,0x0C,0x43,0x51,0x1C,0x07,0x1B,0xC7,0x30,0x04,0x41,0x00);
//Blank 22
        dsi_dcs_write_seq(dsi,0x50,0x5A,0x16);
        dsi_dcs_write_seq(dsi,0x80,0x02,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00);
        dsi_dcs_write_seq(dsi,0x90,0x00,0x00,0x00,0x00,0xC0,0x40);
//Blank 24
        dsi_dcs_write_seq(dsi,0x50,0x5A,0x18);
        dsi_dcs_write_seq(dsi,0x80,0xEF,0xBD,0xF7,0xDE,0x7B,0xEF,0xBD,0x07,0x08,0x08,0x0A,0x0C,0x0C,0x0C,0x0C,0x0C);
        dsi_dcs_write_seq(dsi,0x90,0x0C,0x0C,0x0C,0x5C,0x09,0xA8,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0x5A);
        dsi_dcs_write_seq(dsi,0xA0,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x09,0x04,0xFF,0x05,0x80);
        dsi_dcs_write_seq(dsi,0xB0,0x80,0x00,0x04,0x20,0x00,0x01,0x08,0x40,0x00,0x02,0x10,0x80,0x00,0x04,0x0F);
//Blank 25
        dsi_dcs_write_seq(dsi,0x50,0x5A,0x19);
        dsi_dcs_write_seq(dsi,0x80,0x95,0x93,0x8F,0x8C,0x80,0x8B,0x89,0x87,0x86,0x84,0x83,0x83,0x00,0x60,0xF6,0xFF);
        dsi_dcs_write_seq(dsi,0x90,0xFF,0x2F,0xF3,0xEF,0xFF,0xBF,0x0F,0x0F,0xAF,0xB5,0x71,0x0E,0x6C,0x4A,0x69,0x08);
        dsi_dcs_write_seq(dsi,0xA0,0x00,0x00,0x00,0x00,0x00,0x00,0x00);
//Blank 26
        dsi_dcs_write_seq(dsi,0x50,0x5A,0x1A);
        dsi_dcs_write_seq(dsi,0x80,0x00,0x04,0x08,0x0C,0x00,0x10,0x14,0x18,0x1C,0x00,0x20,0x28,0x30,0x38,0x00,0x40);
        dsi_dcs_write_seq(dsi,0x90,0x48,0x50,0x58,0x00,0x60,0x68,0x70,0x78,0x00,0x80,0x88,0x90,0x98,0x00,0xA0,0xA8);
        dsi_dcs_write_seq(dsi,0xA0,0xB0,0xB8,0x00,0xC0,0xC8,0xD0,0xD8,0x00,0xE0,0xE8,0xF0,0xF8,0x00,0xFC,0xFE,0xFF);
        dsi_dcs_write_seq(dsi,0xB0,0x00,0x00,0x04,0x08,0x0C,0x00,0x10,0x14,0x18,0x1C,0x00,0x20,0x28,0x30,0x38,0x00);
        dsi_dcs_write_seq(dsi,0xC0,0x40,0x48,0x50,0x58,0x00,0x60,0x68,0x70,0x78,0x00,0x80,0x88,0x90,0x98,0x00,0xA0);
        dsi_dcs_write_seq(dsi,0xD0,0xA8,0xB0,0xB8,0x00,0xC0,0xC8,0xD0,0xD8,0x00,0xE0,0xE8,0xF0,0xF8,0x00,0xFC,0xFE);
        dsi_dcs_write_seq(dsi,0xE0,0xFF,0x00,0x00,0x04,0x08,0x0C,0x00,0x10,0x14,0x18,0x1C,0x00,0x20,0x28,0x30,0x38);
        dsi_dcs_write_seq(dsi,0xF0,0x00,0x40,0x48,0x50,0x58,0x00,0x60,0x68,0x70,0x78,0x00,0x80,0x88,0x90,0x98,0x00);
//Blank 27
        dsi_dcs_write_seq(dsi,0x50,0x5A,0x1B);
        dsi_dcs_write_seq(dsi,0x80,0xA0,0xA8,0xB0,0xB8,0x00,0xC0,0xC8,0xD0,0xD8,0x00,0xE0,0xE8,0xF0,0xF8,0x00,0xFC);
        dsi_dcs_write_seq(dsi,0x90,0xFE,0xFF,0x00,0x00);
//Blank 32
        dsi_dcs_write_seq(dsi,0x50,0x5A,0x20);
        dsi_dcs_write_seq(dsi,0x80,0x90,0x00,0x00,0x00,0x00,0x00,0x00);
//Blank 34
        dsi_dcs_write_seq(dsi,0x50,0x5A,0x22);
        dsi_dcs_write_seq(dsi,0x80,0x2D,0xD3,0x00,0x41,0x10,0x04,0x41,0x10,0x04,0x41,0x10,0x1E,0x00);
//Blank 35
        dsi_dcs_write_seq(dsi,0x50,0x5A,0x23);
        dsi_dcs_write_seq(dsi,0x80,0x01,0x05,0x00,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00);
        dsi_dcs_write_seq(dsi,0x90,0xFF,0x00,0x00,0x00,0x24,0x00,0x00,0x00,0x00);
//Blank 36
        dsi_dcs_write_seq(dsi,0x50,0x5A,0x24);
        dsi_dcs_write_seq(dsi,0x80,0x00,0x03,0x00,0x9D,0xBF,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x54);
//SPI not FINISH
//      dsi_dcs_write_seq(0x90,0x5A);
//SPI FINISH
        dsi_dcs_write_seq(dsi,0x90,0xA5);
//Blank select 2F
        dsi_dcs_write_seq(dsi,0x50,0x5A,0x2F);
	dsi_dcs_write_seq(dsi,0x09,0x01);

	printk(KERN_ERR "lincoln_PANEL_INIT: End of Init");

	return 0;
}

static int lincoln_panel_on(struct lincoln_panel *lincoln)
{
	struct mipi_dsi_device *dsi = lincoln->dsi;
	struct device *dev = &lincoln->dsi->dev;
	int ret;

	dsi->mode_flags |= MIPI_DSI_MODE_LPM;

	printk(KERN_ERR "lincoln_PANEL_ON: Beginning of Panel_on");

        ret = mipi_dsi_dcs_exit_sleep_mode(dsi);

	msleep_interruptible(120);

	ret = mipi_dsi_dcs_set_display_on(dsi);
	if (ret < 0)
		dev_err(dev, "failed to set display on: %d\n", ret);

	msleep_interruptible(10);


	printk(KERN_ERR "lincoln_PANEL_ON: End of Panel_on");

	return ret;
}

static void lincoln_panel_off(struct lincoln_panel *lincoln)
{
	struct mipi_dsi_device *dsi = lincoln->dsi;
	struct device *dev = &lincoln->dsi->dev;
	int ret;

	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;

	ret = mipi_dsi_dcs_set_display_off(dsi);
	if (ret < 0)
		dev_err(dev, "failed to set display off: %d\n", ret);

	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
	if (ret < 0)
		dev_err(dev, "failed to enter sleep mode: %d\n", ret);

	msleep_interruptible(100);
}

static int lincoln_panel_disable(struct drm_panel *panel)
{
	struct lincoln_panel *lincoln = to_lincoln_panel(panel);

	if (!lincoln->enabled)
		return 0;

	lincoln->enabled = false;

	return 0;
}

static int lincoln_panel_unprepare(struct drm_panel *panel)
{
	struct lincoln_panel *lincoln = to_lincoln_panel(panel);
	struct device *dev = &lincoln->dsi->dev;
	int ret;

	if (!lincoln->prepared)
		return 0;

	lincoln_panel_off(lincoln);

	gpiod_set_value_cansleep(lincoln->enable_gpio, 1);

	gpiod_set_value_cansleep(lincoln->reset_gpio, 0);

	gpiod_set_value_cansleep(lincoln->dcdc_en_gpio, 1);

	lincoln->prepared = false;

	return 0;
}

static int lincoln_panel_prepare(struct drm_panel *panel)
{
	struct lincoln_panel *lincoln = to_lincoln_panel(panel);
	struct device *dev = &lincoln->dsi->dev;
	int ret;

	if (lincoln->prepared)
		return 0;


	printk(KERN_ERR "lincoln_PANEL_PREPARE: Beginning of Panel_prepare");

	msleep_interruptible(1000);

	gpiod_set_value_cansleep(lincoln->dcdc_en_gpio, 1);
	usleep_range(10, 20);

	gpiod_set_value_cansleep(lincoln->reset_gpio, 0);
	usleep_range(10, 20);

	gpiod_set_value_cansleep(lincoln->enable_gpio, 1);
	usleep_range(10, 20);

	msleep_interruptible(120);

	ret = lincoln_panel_init(lincoln);
	if (ret < 0) {
		dev_err(dev, "failed to init panel: %d\n", ret);
		goto poweroff;
	}

	ret = lincoln_panel_on(lincoln);
	if (ret < 0) {
		dev_err(dev, "failed to set panel on: %d\n", ret);
		goto poweroff;
	}

	lincoln->prepared = true;

	printk(KERN_ERR "lincoln_PANEL_PREPARE: End of Panel_prepare");

	return 0;

poweroff:

	gpiod_set_value_cansleep(lincoln->enable_gpio, 0);

	gpiod_set_value_cansleep(lincoln->reset_gpio, 1);

	gpiod_set_value_cansleep(lincoln->dcdc_en_gpio, 0);

	return ret;
}

static int lincoln_panel_enable(struct drm_panel *panel)
{
	struct lincoln_panel *lincoln = to_lincoln_panel(panel);

	if (lincoln->enabled)
		return 0;

	lincoln->enabled = true;

	return 0;
}

static const struct drm_display_mode default_mode = {
		.clock = 145000,
		.hdisplay = 1200,
		.hsync_start = 1200 + 12,
		.hsync_end = 1200 + 12 + 8,
		.htotal = 1200 + 12 + 8 + 12,
		.vdisplay = 1920,
		.vsync_start = 1920 + 67,
		.vsync_end = 1920 + 67 + 5,
		.vtotal = 1920 + 67 + 5 + 16,
		.flags = 0,
};

static int lincoln_panel_get_modes(struct drm_panel *panel,
			       struct drm_connector *connector)
{
	struct drm_display_mode *mode;
	struct lincoln_panel *lincoln = to_lincoln_panel(panel);
	struct device *dev = &lincoln->dsi->dev;

	mode = drm_mode_duplicate(connector->dev, &default_mode);
	if (!mode) {
		dev_err(dev, "failed to add mode %ux%ux@%u\n",
			default_mode.hdisplay, default_mode.vdisplay,
			drm_mode_vrefresh(&default_mode));
		return -ENOMEM;
	}

	drm_mode_set_name(mode);

	drm_mode_probed_add(connector, mode);

	connector->display_info.width_mm = 95;
	connector->display_info.height_mm = 151;

	return 1;
}

static const struct drm_panel_funcs lincoln_panel_funcs = {
	.disable = lincoln_panel_disable,
	.unprepare = lincoln_panel_unprepare,
	.prepare = lincoln_panel_prepare,
	.enable = lincoln_panel_enable,
	.get_modes = lincoln_panel_get_modes,
};

static const struct of_device_id lincoln_of_match[] = {
	{ .compatible = "lincoln,7v070wuv", },
	{ }
};
MODULE_DEVICE_TABLE(of, lincoln_of_match);

static int lincoln_panel_add(struct lincoln_panel *lincoln)
{
	struct device *dev = &lincoln->dsi->dev;
	int ret;
	unsigned int i;

	lincoln->mode = &default_mode;


	lincoln->enable_gpio = devm_gpiod_get(dev, "enable", GPIOD_OUT_LOW);
	if (IS_ERR(lincoln->enable_gpio)) {
		ret = PTR_ERR(lincoln->enable_gpio);
		dev_err(dev, "cannot get enable-gpio %d\n", ret);
		return ret;
	}

	lincoln->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
	if (IS_ERR(lincoln->reset_gpio)) {
		ret = PTR_ERR(lincoln->reset_gpio);
		dev_err(dev, "cannot get reset-gpios %d\n", ret);
		return ret;
	}

	lincoln->dcdc_en_gpio = devm_gpiod_get(dev, "dcdc-en", GPIOD_OUT_LOW);
	if (IS_ERR(lincoln->dcdc_en_gpio)) {
		ret = PTR_ERR(lincoln->dcdc_en_gpio);
		dev_err(dev, "cannot get dcdc-en-gpio %d\n", ret);
		return ret;
	}

	drm_panel_init(&lincoln->base, &lincoln->dsi->dev, &lincoln_panel_funcs,
		       DRM_MODE_CONNECTOR_DSI);

	drm_panel_add(&lincoln->base);

	return 0;
}

static void lincoln_panel_del(struct lincoln_panel *lincoln)
{
	if (lincoln->base.dev)
		drm_panel_remove(&lincoln->base);
}

static int lincoln_panel_probe(struct mipi_dsi_device *dsi)
{
	struct lincoln_panel *lincoln;
	int ret;

	dsi->lanes = 4;
	dsi->format = MIPI_DSI_FMT_RGB888;
	dsi->mode_flags =  MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_SYNC_PULSE | MIPI_DSI_MODE_LPM;

	lincoln = devm_kzalloc(&dsi->dev, sizeof(*lincoln), GFP_KERNEL);
	if (!lincoln)
		return -ENOMEM;

	mipi_dsi_set_drvdata(dsi, lincoln);

	lincoln->dsi = dsi;

	ret = lincoln_panel_add(lincoln);
	if (ret < 0)
		return ret;

	ret = mipi_dsi_attach(dsi);
	if (ret < 0) {
		lincoln_panel_del(lincoln);
		return ret;
	}

	return 0;
}

static void lincoln_panel_remove(struct mipi_dsi_device *dsi)
{
	struct lincoln_panel *lincoln = mipi_dsi_get_drvdata(dsi);
	int ret;

	ret = lincoln_panel_disable(&lincoln->base);
	if (ret < 0)
		dev_err(&dsi->dev, "failed to disable panel: %d\n", ret);

	ret = mipi_dsi_detach(dsi);
	if (ret < 0)
		dev_err(&dsi->dev, "failed to detach from DSI host: %d\n",
			ret);

	lincoln_panel_del(lincoln);

}

static void lincoln_panel_shutdown(struct mipi_dsi_device *dsi)
{
	struct lincoln_panel *lincoln = mipi_dsi_get_drvdata(dsi);

	lincoln_panel_disable(&lincoln->base);
}

static struct mipi_dsi_driver lincoln_panel_driver = {
	.driver = {
		.name = "panel-lincoln-7v070wuv",
		.of_match_table = lincoln_of_match,
	},
	.probe = lincoln_panel_probe,
	.remove = lincoln_panel_remove,
	.shutdown = lincoln_panel_shutdown,
};
module_mipi_dsi_driver(lincoln_panel_driver);

MODULE_AUTHOR("Steffen Dohse <steffen-dohse@web.de>");
MODULE_DESCRIPTION("lincoln 7v070wuv WUXGA");
MODULE_LICENSE("GPL v2");
